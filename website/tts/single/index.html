<!DOCTYPE html>
<html>
<head>
  <meta charset='utf-8'>
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>

  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">

  <title>Text to Speech</title>

<body>
  <!--<iframe src="silence.mp3" allow="autoplay" id="audio" style="display:none"></iframe>-->
  <iframe src="https://olafwempe.com/mp3/silence/silence.mp3" type="audio/mp3" allow="autoplay" id="audio" style="display:none"></iframe>
  <audio id="player" controls="" style="display:none">
    <source id="source" type="audio/wav">
  </audio>
  <script>
    const eventify = (arr, callback) => {
      arr.push = function(e) {
        Array.prototype.push.call(arr, e)
        callback(arr)
      }
    }

    const sleep = (ms) => { return new Promise(resolve => setTimeout(resolve, ms)) }

    let useQueue = !!findGetParameter("queue")
    let audioPlaying = false
    let msgQueue = []
    let currentMessage = []

    eventify(msgQueue, async (arr) => {
      if (audioPlaying && useQueue) return

      currentMessage = arr.shift()
      let msgObj = currentMessage.shift()
      if (msgObj) {
        audioPlaying = true
        await speak(msgObj.message, msgObj.voice)
      }
    })

    document.getElementById("player").addEventListener("ended", async () => {
      if (currentMessage.length > 0) {
        let msgObj = currentMessage.shift()
        await speak(msgObj.message, msgObj.voice)
        return
      }

      // Delay between messages
      await sleep(parseInt(findGetParameter("cooldown")) || 1000)

      if (msgQueue.length > 0) {
        currentMessage = msgQueue.shift()
        let msgObj = currentMessage.shift()
        if (msgObj) {
          await speak(msgObj.message, msgObj.voice)
          return
        }
      }

      audioPlaying = false
    })

    function findGetParameter(parameterName) {
      let result = null
      let tmp = []
      location.search
        .substr(1)
        .split("&")
        .forEach(function (item) {
          tmp = item.split("=")
          if (tmp[0].toLowerCase() === parameterName.toLowerCase()) {
            result = decodeURIComponent(tmp[1])
          }
        })
      return result
    }

    async function speak (text, voice = "Brian") {
      let speak = await fetch("https://api.streamelements.com/kappa/v2/speech?voice=" +
        voice +
        "&text=" +
        encodeURIComponent(text.trim()))

      if (speak.status !== 200) {
        console.warn(await speak.text())
        return
      }

      let mp3 = await speak.blob()

      let blobUrl = URL.createObjectURL(mp3)
      document.getElementById("source").setAttribute("src", blobUrl)
      let player = document.getElementById("player")
      player.pause()
      player.load()
      player.play()
    }

    function connect () {
      let socket = new WebSocket(!!findGetParameter('local') ? 'ws://localhost:4700' : 'wss://ws.icecreamdatabase.com')
      // Connection opened
      socket.addEventListener('open', function (event) {
        console.log("Connected")
        socket.send(JSON.stringify({channel: (findGetParameter("channel") || "").toLowerCase()}))
      })

      // Listen for messages
      socket.addEventListener('message', async function (event) {
        let obj = JSON.parse(event.data)
        if (obj.data && obj.channel && obj.channel.toLowerCase() === (findGetParameter("channel") || "").toLowerCase()) {
          msgQueue.push(obj.data)
        }
      })

      socket.addEventListener('close', event => {
        socket = null
        connect()
      })
      socket.addEventListener('error', event => {
        //socket = null
        //connect()
      })
    }
    connect()

  </script>